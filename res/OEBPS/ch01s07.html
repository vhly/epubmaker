<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Object Lifecycle</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="Object Lifecycle"><div class="titlepage"><div><div><h1 class="title"><a id="objectcpr-CHP-1-SECT-7"/>Object Lifecycle</h1></div></div></div><p>Your <a id="objectcpr-IDXTERM-293" class="indexterm"/> <a id="objectcpr-IDXTERM-294" class="indexterm"/>classes will have methods that distinguish them from other
      classes and make them useful, but all classes must implement methods
      that manage their lifecycle—allocation, initialization, copying, and
      deletion. In addition, you will use library classes that come supplied
      with these methods, which you need to use in a consistent way. This
      section describes the design patterns that Objective-C programmers use
      and that library classes support.</p><p>The root classes <code class="literal">Object</code>
      <a id="objectcpr-IDXTERM-295" class="indexterm"/> and <code class="literal">NSObject</code>
      <a id="objectcpr-IDXTERM-296" class="indexterm"/> provide the following methods for managing the lifecycles
      of objects:</p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="literal">+initialize</code></td></tr><tr><td><code class="literal">+alloc</code></td></tr><tr><td><code class="literal">+new</code></td></tr><tr><td><code class="literal">-init</code></td></tr><tr><td><code class="literal">-copy</code></td></tr><tr><td><code class="literal">-dealloc</code></td></tr></table><p>In addition, <code class="literal">Object</code> also
      provides these methods:</p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="literal">-shallowCopy</code></td></tr><tr><td><code class="literal">-deepCopy</code></td></tr><tr><td><code class="literal">-deepen</code></td></tr><tr><td><code class="literal">-free</code></td></tr></table><p>In addition to these methods, many classes will provide more
      methods for initializing newly allocated objects.</p><p><a class="link" href="ch01s10.html" title="Root Classes">Section 1.10</a>
      describes how these methods behave for the root classes; this section
      gives you guidelines on how to actually use the methods in your
      programs.</p><p>In managing the lifecycle of an object, you are faced with two
      issues: how to call these methods and how to write them for your own
      classes. Each of the following sections will first discuss how to call
      the methods, and then how to write them.</p><div class="sect2" title="Creating an Object"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-7.1"/>Creating an Object</h2></div></div></div><p>Objective-C separates <a id="objectcpr-IDXTERM-297" class="indexterm"/>object creation into two steps: <a id="objectcpr-IDXTERM-298" class="indexterm"/> <a id="objectcpr-IDXTERM-299" class="indexterm"/>allocating memory and <a id="IXT-1-238" class="indexterm"/> <a id="IXT-1-239" class="indexterm"/>initializing fields. Allocation returns a pointer to
        cleared memory where the object will be stored. Initializing an object
        means setting its fields to some values, either default or specified.
        These operations serve distinct purposes, are performed by different
        objects (allocation by a class, and initialization by an instance),
        and you write and call each of them explicitly.</p><div class="sect3" title="Calling creation methods"><div class="titlepage"><div><div><h3 class="title"><a id="objectcpr-CHP-1-SECT-7.1.1"/>Calling creation methods</h3></div></div></div><p>To <a id="IXT-1-240" class="indexterm"/>create an object, you first ask its class to allocate
          memory, and then you initialize the instance:</p><a id="I_1_tt46"/><pre class="programlisting">1<em class="replaceable"><code>Circle</code></em>* <em class="replaceable"><code>c</code></em> = [<em class="replaceable"><code>Circle</code></em> alloc];
2 <em class="replaceable"><code>c</code></em> = [<em class="replaceable"><code>c</code></em> init];</pre><p>Line 1. In Objective-C you call a class method to return a
          pointer to memory for a new object. It is conventional to call this
          method <code class="literal">+alloc</code> <a id="IXT-1-241" class="indexterm"/>. Both <code class="literal">Object</code> and
          <code class="literal">NSObject</code> supply an <code class="literal">+alloc</code> method. The object you get from
          <code class="literal">+alloc</code> will have all its fields
          set to zero.</p><p>Line 2. An <span class="emphasis"><em>initializer</em></span> is an instance
          method that sets the fields of a newly allocated object. Every
          object responds to the <code class="literal">-init</code>
          <a id="IXT-1-242" class="indexterm"/> message, which it inherits from the root class. The
          root class version does nothing, but leaves the object in its
          pristine just-allocated state. Descendants may override <code class="literal">-init</code> to provide a default
          initialization.</p><p>An initializer returns the initialized object, but that object
          may be different from the receiver of the initialization message.
          For example, an initializer may fail and return <strong class="userinput"><code>nil</code></strong>, or substitute a proxy or other
          special object for the one passed in. For this reason it is not safe
          to call an initializer as a void method:</p><a id="I_1_tt47"/><pre class="programlisting">[<em class="replaceable"><code>c</code></em> init];  // Discards return value.</pre><p>In this example, any return value is discarded. If <code class="literal">-init</code> returns an object different from the
          receiver, this code will lose that object and the receiver will not
          be correctly initialized. To avoid this problem, chain the calls to
          allocate and initialize your objects, or use the <code class="literal">new</code> method, which does this for you (but
          only for the bare-bones <code class="literal">-init</code>
          method). Both of the following lines allocate and initialize an
          instance of <em class="replaceable"><code>Circle</code></em>:</p><a id="I_1_tt48"/><pre class="programlisting"><em class="replaceable"><code>Circle</code></em>* <em class="replaceable"><code>c1</code></em> = [[<em class="replaceable"><code>Circle</code></em> alloc] init];
<em class="replaceable"><code>Circle</code></em>* <em class="replaceable"><code>c2</code></em> = [<em class="replaceable"><code>Circle</code></em> new];  // Same effect.</pre><p>Many classes will supply more initialization methods; it is
          conventional for their names to start with <code class="literal">init</code>. These methods may take additional
          parameters to guide the setting up of the receiver's state. For
          example:</p><a id="I_1_tt49"/><pre class="programlisting"><em class="replaceable"><code>Circle</code></em>* <em class="replaceable"><code>c</code></em> = [[<em class="replaceable"><code>Circle</code></em> alloc] <em class="replaceable"><code>initWithRadius</code></em>:3];</pre></div><div class="sect3" title="Writing creation methods"><div class="titlepage"><div><div><h3 class="title"><a id="objectcpr-CHP-1-SECT-7.1.2"/>Writing creation methods</h3></div></div></div><p>Your <a id="IXT-1-243" class="indexterm"/>code should maintain the separation of allocation and
          initialization. You must also implement the chaining of <a id="IXT-1-244" class="indexterm"/>initializers that ensures that objects are initialized
          first as instances of their root class, and successively as
          instances of more derived classes.</p><p>To coordinate these steps you are obliged to manage details of
          object creation that other languages automate. The advantage is that
          you can more easily understand the behavior of your program by
          direct inspection.</p><p>Your class should always inherit or provide a class method for
          returning a pointer to cleared memory where the object will be
          stored. You shouldn't override this method in subclasses. In
          addition to reserving memory, <code class="literal">+alloc</code> needs to set up the internal
          structure of an object before it is initialized. This makes writing
          a root class difficult, and your class should usually inherit its
          <a id="IXTR3-564" class="indexterm"/> <a id="IXTR3-565" class="indexterm"/>allocator from a root
          class provided by your development environment. Both <code class="literal">Object</code> and <code class="literal">NSObject</code> supply an <code class="literal">+alloc</code> method. If you need to write your
          own root class, look at <span class="emphasis"><em>Object.m</em></span> to see how
          this is done.</p><p>When an <a id="IXT-1-245" class="indexterm"/>object is initialized, it should become a valid,
          consistent instance of its class. For this to happen, all
          Objective-C classes need to cooperate to ensure several
          things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>All the ancestors of a class must initialize an object
              before the class itself does.</p></li><li class="listitem"><p><a id="IXT-1-246" class="indexterm"/>Ancestor initialization must proceed in order from
              the root class to the most-derived class.</p></li><li class="listitem"><p>All ancestor initialization calls should be usable on a
              class's instance. (The difficulty here is guaranteeing that the
              class's own initialization will not be skipped.)</p></li></ul></div><p>Objective-C programmers have adopted the following design
          patterns to ensure these conditions are always met:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Your class may have several initialization methods; it is
              conventional to name those methods starting with <code class="literal">init</code>.</p></li><li class="listitem"><p>The most specialized initializer (usually the one with the
              most parameters) is called the <span class="emphasis"><em>designated
              initializer</em></span> <a id="objectcpr-IDXTERM-311" class="indexterm"/> <a id="objectcpr-IDXTERM-312" class="indexterm"/> and has a special role: all your class's other
              initializers should call it.</p></li><li class="listitem"><p>Your class should override the <a id="objectcpr-IDXTERM-313" class="indexterm"/>parent class's designated initializer.</p></li><li class="listitem"><p>Your designated initializer should call the parent class's
              designated initializer.</p></li></ul></div><p>The rationale for these guidelines is presented in the next
          section in the context of a concrete example.</p></div><div class="sect3" title="Sample code for initialization"><div class="titlepage"><div><div><h3 class="title"><a id="objectcpr-CHP-1-SECT-7.1.3"/>Sample code for initialization</h3></div></div></div><p>The <a id="objectcpr-IDXTERM-314" class="indexterm"/> <a id="objectcpr-IDXTERM-315" class="indexterm"/>following code illustrates the design pattern you
          should follow to ensure correct initialization of your objects. In
          the example, you are writing the <a id="objectcpr-IDXTERM-316" class="indexterm"/>subclass <em class="replaceable"><code>MyClass</code></em>. We assume
          the parent class follows the same rules we illustrate in the
          subclass.</p><a id="I_1_tt50"/><pre class="programlisting"> 1<strong class="userinput"><code> @interface</code></strong> 
                  <em class="replaceable"><code>Parent </code></em>: Object {
 2   <strong class="userinput"><code>int</code></strong> 
                  <em class="replaceable"><code>i</code></em>;
 3 }
 4   -(<strong class="userinput"><code>id</code></strong>)init;
 5   -(<strong class="userinput"><code>id</code></strong>)<em class="replaceable"><code>initWithI</code></em>:(<strong class="userinput"><code>int</code></strong>)<em class="replaceable"><code>val</code></em>;
 6<strong class="userinput"><code> @end</code></strong>
 7
 8<strong class="userinput"><code> @interface</code></strong> 
                  <em class="replaceable"><code>MyClass</code></em> : <em class="replaceable"><code>Parent</code></em> {
 9   <strong class="userinput"><code>int</code></strong> 
                  <em class="replaceable"><code>j</code></em>;
10 }
11   -(<strong class="userinput"><code>id</code></strong>)<em class="replaceable"><code>initWithI</code></em>:(<strong class="userinput"><code>int</code></strong>)<em class="replaceable"><code>iVal</code></em>;
12   -(<strong class="userinput"><code>id</code></strong>)<em class="replaceable"><code>initWithI</code></em>:(<strong class="userinput"><code>int</code></strong>)<em class="replaceable"><code>iVal</code></em> 
                  <em class="replaceable"><code>andJ</code></em>:(<strong class="userinput"><code>int</code></strong>)<em class="replaceable"><code>jVal</code></em>;
13<strong class="userinput"><code> @end</code></strong>
14
15<strong class="userinput"><code> @implementation</code></strong> 
                  <em class="replaceable"><code>MyClass</code></em>
16   -(<strong class="userinput"><code>id</code></strong>)<em class="replaceable"><code>initWithI</code></em>:(<strong class="userinput"><code>int</code></strong>)<em class="replaceable"><code>iVal</code></em> {
17     <strong class="userinput"><code>return</code></strong> [<strong class="userinput"><code>self</code></strong> 
                  <em class="replaceable"><code>initWithI</code></em>:<em class="replaceable"><code>iVal</code></em> 
                  <em class="replaceable"><code>andJ</code></em>:42];
18   }
19   -(<strong class="userinput"><code>id</code></strong>)<em class="replaceable"><code>initWithI</code></em>:(<strong class="userinput"><code>int</code></strong>)<em class="replaceable"><code>iVal</code></em> 
                  <em class="replaceable"><code>andJ</code></em>:(<strong class="userinput"><code>int</code></strong>)<em class="replaceable"><code>jVal</code></em> {
20     <strong class="userinput"><code>if</code></strong> (<strong class="userinput"><code>self</code></strong> = [<strong class="userinput"><code>super</code></strong> 
                  <em class="replaceable"><code>initWithI</code></em>:<em class="replaceable"><code>iVal</code></em>]) {
21       <em class="replaceable"><code>j</code></em> = <em class="replaceable"><code>jVal</code></em>;
22     }
23     <strong class="userinput"><code>return</code></strong> 
                  <strong class="userinput"><code>self</code></strong>;
24   }
25<strong class="userinput"><code> @end</code></strong></pre><p>Line 4. All initializers return <strong class="userinput"><code>id</code></strong>. This class has a simple <code class="literal">-init</code> method, taking no parameters. It
          calls (funnels to) <code class="literal">-initWithI</code>:
          passing in a default value.</p><p>Line 5. <em class="replaceable"><code>Parent</code></em> provides another
          initializer, <code class="literal">initWithI:</code>, which
          lets you specify the value of the field
          <em class="replaceable"><code>i</code></em>. This is the designated
          initializer.</p><p>Line 11. <em class="replaceable"><code>MyClass</code></em> overrides (covers)
          its parent's designated initializer. Always do this in your
          classes.</p><div class="note" title="Note"><h3 class="title"><a id="ch01-16-fm2xml"/>Note</h3><p>If you don't cover a parent's designated initializer, code
            such as:</p><a id="I_1_tt51"/><pre class="programlisting"><em class="replaceable"><code>MyClass</code></em>* <em class="replaceable"><code>obj</code></em> = 
   [[<em class="replaceable"><code>MyClass</code></em> alloc] <em class="replaceable"><code>initWithI</code></em>:42];</pre><p>will go straight to the parent class's initializer and leave
            <em class="replaceable"><code>j</code></em> undefined.</p></div><p>You must cover all the parent class's initializers; if the
          parent class funnels all its initializers through the designated
          initializer (as we are assuming here), overriding it will cover them
          all. Full coverage ensures that your subclass instances will be
          substitutable for parent class instances.</p><p>Line 12. Provide specialized initializers for your class's
          specific new features. This method is the designated initializer for
          <em class="replaceable"><code>MyClass</code></em>.</p><p>Line 17. All your class's other initializers should call
          (funnel to) your class's designated initializer. Funneling lets
          future subclasses cover all your initializers by just overriding the
          designated initializer. Pass in to your designated initializer some
          desired default value for parameters not specified in the simpler
          initializer.</p><p>Line 20. Your designated initializer should first call (chain
          to) the parent's designated initializer. Calling the parent
          initializer ensures that all the parent classes will get their
          chance to initialize the object.</p><div class="note" title="Note"><h3 class="title"><a id="ch01-18-fm2xml"/>Note</h3><p>Calling the parent designated initializer avoids a circular
            call path: if instead you called <code class="literal">-init</code> here, its (presumed) call to
            <code class="literal">-initWithI</code>: would be dispatched
            to your new version, and from there back to this method.</p></div><p>You first assign the result of the chaining call to <strong class="userinput"><code>self</code></strong>, in case the call returns an object
          different from the receiver. Then test for <strong class="userinput"><code>nil</code></strong> (the <strong class="userinput"><code>if</code></strong> statement does this) in case the
          <a id="IXTR3-566" class="indexterm"/>parent class failed to
          initialize the object.</p><p>Line 21. Your designated initializer performs class-specific
          work.</p><p>Line 23. If your initializer fails, it should return
          <strong class="userinput"><code>nil</code></strong>. The way this example is
          written, that happens automatically. If your initializer performs
          more complicated steps, you may have <a id="IXTR3-567" class="indexterm"/> <a id="IXTR3-568" class="indexterm"/>to ensure this
          <a id="IXTR3-569" class="indexterm"/> <a id="IXTR3-570" class="indexterm"/>explicitly.</p></div><div class="sect3" title="Initializing classes"><div class="titlepage"><div><div><h3 class="title"><a id="objectcpr-CHP-1-SECT-7.1.4"/>Initializing classes</h3></div></div></div><p>The <a id="IXT-1-247" class="indexterm"/>runtime system will call a class's <code class="literal">+initialize</code> <a id="IXT-1-248" class="indexterm"/> class method some time before that class or any of
          its descendant classes is used. Each class will receive the
          initialize message before any of its subclasses. If you have some
          set-up code for the class as a whole (apart from its instances) you
          should implement this method.</p><p>If your class implements <code class="literal">+initialize</code> but it has a <a id="IXTR3-571" class="indexterm"/>subclass that does not,
          the call to initialize the subclass will be handled by your
          class—that is, your class will receive the message more than once.
          For this reason, you should guard against multiple calls in your
          method:</p><a id="I_1_tt52"/><pre class="programlisting">+(<strong class="userinput"><code>id</code></strong>)initialize {
  <strong class="userinput"><code>static</code></strong> 
                  <strong class="userinput"><code>BOOL</code></strong> 
                  <em class="replaceable"><code>done</code></em> = <strong class="userinput"><code>NO</code></strong>;
  <strong class="userinput"><code>if</code></strong> (!<em class="replaceable"><code>done</code></em>) {
    // Your initialization here.
    <em class="replaceable"><code>done</code></em> = <strong class="userinput"><code>YES</code></strong>;
  }
  <strong class="userinput"><code>return</code></strong> 
                  <strong class="userinput"><code>self</code></strong>;
}</pre><p>This example is for descendants of <code class="literal">Object</code>; the <code class="literal">NSObject</code> version of <code class="literal">+initialize</code> returns <strong class="userinput"><code>void</code></strong> instead of returning <a id="IXTR3-572" class="indexterm"/>an <strong class="userinput"><code>id</code></strong>.</p></div></div><div class="sect2" title="Copying an Object"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-7.2"/>Copying an Object</h2></div></div></div><p>When <a id="objectcpr-IDXTERM-326" class="indexterm"/>an object has only value types for fields (apart from
        the <code class="literal">isa</code> pointer), making a copy is
        a simple matter of duplicating all the fields in a new memory
        location. When some of the fields are pointers, there are two types of
        copy that you can make:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="emphasis"><em>shallow copy</em></span> <a id="IXT-1-249" class="indexterm"/> duplicates the pointers by value, so the new object
            refers to the same objects as did the original one.</p></li><li class="listitem"><p>A <span class="emphasis"><em>deep copy</em></span> <a id="IXT-1-250" class="indexterm"/> duplicates the objects pointed to, and continues
            this process, traversing all the pointers of duplicated
            objects.</p></li></ul></div><p>The root classes provide a basic framework of copy methods, but
        your classes will have to override them to get proper deep
        copying.</p><div class="sect3" title="Calling copy methods"><div class="titlepage"><div><div><h3 class="title"><a id="objectcpr-CHP-1-SECT-7.2.1"/>Calling copy methods</h3></div></div></div><p>The <a id="IXT-1-251" class="indexterm"/>copy methods of <code class="literal">Object</code> all return a shallow copy of the
          <a id="IXT-1-252" class="indexterm"/>receiver. For <code class="literal">Object</code> itself, the distinction between
          deep and shallow is meaningless, since the only pointer it has is
          the <code class="literal">isa</code> pointer, which is
          supposed to be shared between all instances. In descendant classes
          that properly override the methods, their behavior will be as
          follows:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">-(</code> <span class="bold"><strong> <code class="literal">id</code> </strong></span>
              <code class="literal">)copy</code></span></dt><dd><p><a id="IXT-1-253" class="indexterm"/>Returns a <a id="IXT-1-254" class="indexterm"/>deep copy of the receiver.</p></dd><dt><span class="term"><code class="literal">-(</code> <span class="bold"><strong> <code class="literal">id</code> </strong></span>
              <code class="literal">)shallowCopy</code></span></dt><dd><p><a id="IXT-1-255" class="indexterm"/>Returns a shallow copy of the receiver.</p></dd><dt><span class="term"><code class="literal">-(</code> <span class="bold"><strong> <code class="literal">id</code> </strong></span>
              <code class="literal">)deepen</code></span></dt><dd><p><a id="IXT-1-256" class="indexterm"/>Modifies the receiver, replacing all of its
                non-value fields with deep copies.</p></dd><dt><span class="term"><code class="literal">-(</code> <span class="bold"><strong> <code class="literal">id</code> </strong></span>
              <code class="literal">)deepCopy</code></span></dt><dd><p><a id="IXT-1-257" class="indexterm"/>Returns a deep copy of the receiver.</p></dd></dl></div><p>The <code class="literal">NSObject</code> class provides
          only the <code class="literal">-copy</code> method, and it
          simply calls the unimplemented method <code class="literal">-copyWithZone</code> <a id="objectcpr-IDXTERM-336" class="indexterm"/>:. You need to consult a class's documentation to know
          if it supports copying. The next section describes how to implement
          this method yourself to support copying in your classes.</p><p>When you get a copy of an object in Cocoa, it has already been
          retained for you and you will have to call <code class="literal">release</code> on it when you are done with it.
          The <a class="link" href="ch01s12.html" title="Memory Management">Section 1.12</a>
          explains more about retaining and releasing objects.</p></div><div class="sect3" title="Writing copy methods"><div class="titlepage"><div><div><h3 class="title"><a id="objectcpr-CHP-1-SECT-7.2.2"/>Writing copy methods</h3></div></div></div><p>To <a id="objectcpr-IDXTERM-337" class="indexterm"/>implement copying for subclasses of <code class="literal">Object</code>, you only need to override the
          <code class="literal">-deepen</code> method to recursively
          traverse the <a id="objectcpr-IDXTERM-338" class="indexterm"/> <a id="objectcpr-IDXTERM-339" class="indexterm"/>receiver's pointers and replace them with pointers to
          newly allocated objects identical to the originals.</p><p><a id="IXT-1-258" class="indexterm"/>Cocoa doesn't implement any copying methods for you;
          it just declares two copying <a id="IXT-1-259" class="indexterm"/>protocols. These protocols don't distinguish between
          shallow and deep copies: it is up to your classes to decide (and
          document) what kind of copies they will return. The protocols do
          distinguish between <a id="objectcpr-IDXTERM-342" class="indexterm"/>mutable and <a id="objectcpr-IDXTERM-343" class="indexterm"/>immutable copies. A mutable object is one whose values
          can change; an immutable one must stay constant after it is created.
          The protocols are:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">NSCopying</code></span></dt><dd><p><a id="IXT-1-260" class="indexterm"/> <a id="IXT-1-261" class="indexterm"/>Declares the method <code class="literal">-copyWithZone</code>:. Adopt this protocol
                and implement the method to return a copy of the receiver. You
                must at least adopt this protocol to support copying. If you
                also adopt <code class="literal">NSMutableCopying</code>, <code class="literal">-copyWithZone</code>: should return an
                immutable copy.</p></dd><dt><span class="term"><code class="literal">NSMutableCopying</code></span></dt><dd><p><a id="IXT-1-262" class="indexterm"/> <a id="IXT-1-263" class="indexterm"/>Declares the method <code class="literal">-mutableCopyWithZone</code> <a id="IXT-1-264" class="indexterm"/>:. If your class distinguishes between mutable
                and immutable values, adopt this protocol and implement the
                method to return a mutable copy of the receiver.</p></dd></dl></div><p>Each method takes as a parameter a pointer to an <code class="literal">NSZone</code> <a id="IXT-1-265" class="indexterm"/>, which isn't a class but an opaque type. Normally you
          will not look any deeper into the zone parameter, but pass it along
          to an inherited copy method like <code class="literal">-allocWithZone</code>: or a Cocoa runtime
          function like <code class="literal">NSZoneAlloc( )</code>
          <a id="IXT-1-266" class="indexterm"/>. See the <a id="IXT-1-267" class="indexterm"/>Cocoa documentation for information on how to use the
          runtime functions for allocating memory.</p><p>Since <code class="literal">NSObject</code> does not
          implement either protocol, you must adopt and implement the
          protocols if you want your objects to support copying. Your class
          will inherit from <code class="literal">NSObject</code>
          <a id="IXT-1-268" class="indexterm"/>, whose methods <code class="literal">-copy</code> and <code class="literal">-mutableCopy</code> call the respective protocol
          methods (with <strong class="userinput"><code>nil</code></strong> parameters)
          so you can use those simpler methods to make copies of your class's
          instances.</p><p>If the distinction between mutable and immutable doesn't
          matter for your class (all instances are mutable or all are
          immutable), just adopt <code class="literal">NSCopying</code>.
          If instances may be one or the other kind, adopt both <code class="literal">NSCopying</code> and <code class="literal">NSMutableCopying</code>, using the first for
          returning immutable copies and the second for mutable ones.</p><p>If your class doesn't inherit any <code class="literal">-copyWithZone</code>: method, implement it using
          <a id="IXT-1-269" class="indexterm"/>+<code class="literal">allocWithZone</code>: and
          an initialization method. For example:</p><a id="I_1_tt53"/><pre class="programlisting">-(<strong class="userinput"><code>id</code></strong>)copyWithZone:(NSZone*)<em class="replaceable"><code>zone</code></em> {
  <strong class="userinput"><code>return</code></strong> [[[<strong class="userinput"><code>self</code></strong> class] allocWithZone:<em class="replaceable"><code>zone</code></em>] init];
}</pre><p>In this example, you evaluate <code class="literal">[</code> <strong class="userinput"><code>self</code></strong> <code class="literal">class]</code> to get the receiver of the
          allocation message. Don't use the name of your class here. If you
          do, descendants won't be able to inherit this method because the
          kind of object it creates will be hard-wired.</p><p>If your class inherits a <code class="literal">-copyWithZone</code>: method, you might not need
          to change it, for example if your class doesn't add any fields. If
          you do override this method, it should first call the same method on
          <strong class="userinput"><code>super</code></strong> before doing any
          further work. For example:</p><a id="I_1_tt54"/><pre class="programlisting">-(<strong class="userinput"><code>id</code></strong>)copyWithZone:(NSZone*)<em class="replaceable"><code>zone</code></em> {
  <em class="replaceable"><code>MyClass</code></em>* <em class="replaceable"><code>copy</code></em> = [<strong class="userinput"><code>super</code></strong> copyWithZone:<em class="replaceable"><code>zone</code></em>];
  // Further class-specific setup of copy.
  <strong class="userinput"><code>return</code></strong> 
                  <em class="replaceable"><code>copy</code></em>;
}</pre><p>If the inherited method returns a <a id="IXT-1-270" class="indexterm"/>shallow copy, the copy will have two properties you
          will have to correct:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Its <a id="IXT-1-271" class="indexterm"/>reference count will be identical to your own, and
              you will have to set the count to 1.</p></li><li class="listitem"><p>If it has any pointers to reference-counted objects, the
              counts of those objects will not be properly incremented by 1 to
              reflect their additional owner. You should set these fields to
              <strong class="userinput"><code>nil</code></strong> and then initialize
              them using the appropriate setter method.</p></li></ul></div><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>If you don't set a reference to <strong class="userinput"><code>nil</code></strong> first, the setter method may call
            <code class="literal">-release</code> on the referent,
            leaving its reference count permanently off by one.</p></div><p>If objects of your class are immutable, or there is only one
          instance that is shared, just call <code class="literal">-retain</code> <a id="IXT-1-272" class="indexterm"/> on the receiver <a id="IXTR3-573" class="indexterm"/>and return it
          <a id="IXTR3-574" class="indexterm"/>to <a id="IXTR3-575" class="indexterm"/>the <a id="IXTR3-576" class="indexterm"/>caller. <a id="IXTR3-577" class="indexterm"/> <a id="IXTR3-578" class="indexterm"/>For <a id="IXTR3-579" class="indexterm"/>example:</p><a id="I_1_tt55"/><pre class="programlisting">-(<strong class="userinput"><code>id</code></strong>)copyWithZone:(NSZone*)<em class="replaceable"><code>zone</code></em> {
  <strong class="userinput"><code>return</code></strong> [<strong class="userinput"><code>self</code></strong> retain];
}</pre></div></div><div class="sect2" title="Deallocating an Object"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-7.3"/>Deallocating an Object</h2></div></div></div><p>The <a id="IXT-1-273" class="indexterm"/>deallocation method of a class complements both the
        allocation and initializers, undoing the work they did.</p><div class="sect3" title="Calling deallocation methods"><div class="titlepage"><div><div><h3 class="title"><a id="objectcpr-CHP-1-SECT-7.3.1"/>Calling deallocation methods</h3></div></div></div><p>The <a id="IXT-1-274" class="indexterm"/> <code class="literal">Object</code> class
          provides a <code class="literal">-free</code> <a id="IXT-1-275" class="indexterm"/> method. Calling this method releases the memory
          directly associated with the object. Memory directly associated with
          an object includes the space taken up by that object's fields. If a
          field is a pointer to an object or other structure, only the pointer
          will be freed. Subclasses should override this method to adapt its
          behavior to free additional resources held by the receiver.</p><p>The <code class="literal">NSObject</code> class provides
          an analogous method called <code class="literal">-dealloc</code>. It has the same behavior as
          <code class="literal">-free</code>, but you don't normally
          call <code class="literal">-dealloc</code> <a id="IXT-1-276" class="indexterm"/> yourself on an object. Instead you use the reference
          counting methods for memory management, provided by <a id="IXT-1-277" class="indexterm"/>Cocoa. When an object's reference count goes to zero,
          <code class="literal">-dealloc</code> is automatically called.
          See <a class="link" href="ch01s12.html" title="Memory Management">Section 1.12</a> for
          information about using reference counting.</p></div><div class="sect3" title="Writing deallocation methods"><div class="titlepage"><div><div><h3 class="title"><a id="objectcpr-CHP-1-SECT-7.3.2"/>Writing deallocation methods</h3></div></div></div><p>If you're using the <code class="literal">Object</code>
          class, your code will call the <code class="literal">-free</code> methods directly. In Cocoa, the
          runtime will send a <code class="literal">-dealloc</code>
          message to your object when its memory is being freed via the
          <code class="literal">-release</code> <a id="IXT-1-278" class="indexterm"/> message. In either case you use the same approach to
          writing the deallocators.</p><p>Your class's deallocator should first release all resources
          that it has acquired, <span class="emphasis"><em>then</em></span> call its parent
          class's deallocator method:</p><a id="I_1_tt56"/><pre class="programlisting">-(<strong class="userinput"><code>id</code></strong>)free {
  // Release held resources.
  [<strong class="userinput"><code>super</code></strong> free];  // Tail call.
}</pre><p>Notice that this chaining order is reverse that of
          initializing: a tail call instead of a head call.</p><div class="note" title="Note"><h3 class="title"><a id="ch01-19-fm2xml"/>Note</h3><p>Descendants of <code class="literal">NSObject</code>
            will use <code class="literal">-release</code> instead of
            <code class="literal">-free</code>.</p></div><p>Resources to be released include Objective-C objects held by
          reference (call <code class="literal">-free</code> or <code class="literal">-release</code> on these) and external shared
          entities like network sockets. The root class deallocator releases
          the memory of <a id="IXTR3-580" class="indexterm"/>the <a id="IXTR3-581" class="indexterm"/>object (i.e., its
          fields) <a id="IXTR3-582" class="indexterm"/>
          <a id="IXTR3-583" class="indexterm"/>itself.</p></div></div></div></body></html>
